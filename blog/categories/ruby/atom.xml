<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | script the planet]]></title>
  <link href="http://rra3.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rra3.github.io/"/>
  <updated>2014-10-08T23:07:07-04:00</updated>
  <id>http://rra3.github.io/</id>
  <author>
    <name><![CDATA[Robert Arnold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Poor Man's Mongo Interface for Ruby]]></title>
    <link href="http://rra3.github.io/blog/2014/03/22/poor-mans-mongo-interface-for-ruby/"/>
    <updated>2014-03-22T11:53:19-04:00</updated>
    <id>http://rra3.github.io/blog/2014/03/22/poor-mans-mongo-interface-for-ruby</id>
    <content type="html"><![CDATA[<blockquote><p>We will encourage you to develop the three great virtues of a <em>programmer: laziness, impatience</em>, and hubris.
&ndash; Larry Wall, Programming Perl</p></blockquote>

<p>I&rsquo;ve been working in Mongo a lot lately. Initially jazzed by the thrill of using javascript for the query language, I&rsquo;ve since learned that the queries themselves can quite quickly become verbose and ungainly to work with from within the confines of the little CLI mongo shell environment. For longer queries, you do have the option of writing standalone js scripts, resorting to the mongo shell prompt only for smaller, simpler queries. It feels much more natural to think of mongo queries as tiny scripts than something analogous to a SQL query. In fact, Mongo <a href="http://docs.mongodb.org/manual/tutorial/write-scripts-for-the-mongo-shell/">exposes many javascript equivalents</a> that allows you to do just about anything in native javascript that you can do manually from the mongo shell prompt.  After creating and saving your javascript file, you can then pass the saved file directly to mongo:</p>

<p><code>
 mongo [options] [db address] [file names (ending in .js)]
</code></p>

<p>I use vim, and I was delighted to learn that while crafting an involved query I could test it quickly by mapping a key to something like this:</p>

<p><code>
  :w !mongo
</code></p>

<p>Why does this work? Because mongo accepts input from stdin. In your life as a programmer you often have to make compromises for the sake of pragmatism. It can often be quicker to open a system call to external programs rather than taking the time to learn an new api. Depending upon the size and nature of the task, this can be preferable. What is the cost/benefit ratio to doing something in pure Ruby versus delegating to an external program? You have to make that call, but for small tasks, leaning on external tools and programs can be a blessing &ndash; especially those that accept stdin. In my former life as a perl programmer, I learned to open a filehandle directly against a subprocess. This was handy for programs that accept data on stdin, such as sendmail:</p>

<p>```perl
open(SENDMAIL, &ldquo;|/usr/sbin/sendmail -oi -t  -odq&rdquo;)
  or die &ldquo;cannot fork for sendmail: $!\n&rdquo;;</p>

<p>print SENDMAIL &lt;&lt; &ldquo;EOF&rdquo;;
From: Bob &lt;bob\@localhost>
To: Joe &lt;Joe\@somewherez>
Subject: Lunch?</p>

<p>Hey Joe, whaddya know? Got lunch plans?</p>

<p>EOF
```</p>

<p>&hellip;I also love heredocs &ndash; which as you can see above, allow me to write directly to the open SENDMAIL filehandle. Ruby, of course, offers the same flexibility with filehandles. I had nearly forgotten about this until recently when I needed to send an email report from data I had stored in Mongo. I wanted to write the report generator in Ruby, but also didn&rsquo;t want to bother learning a new api for interfacing with Mongo when I had all of my necessary scripts at the ready as javascript. That&rsquo;s when I recalled the above sendmail trick. Here&rsquo;s a variation in Ruby for writing queries to mongo:</p>

<p>```ruby
   def fork_mongo</p>

<pre><code>open("|mongo --quiet -u #{ENV['MONGO_USER']} -p #{ENV['MONGO_PW']} your.mongo.server:27017/some_db", 'w+') do |p|
  p.write('db.orders.aggregate({$match: {status: "A}"}, {$group: {_id: "$cust_id", total: {$sum: "$amount"}}})')
  p.close_write
  p.read
end
</code></pre>

<p>  end
```</p>

<p>Notice that the parameter passed to the open method is preceded by a &ldquo;|&rdquo; symbol, which indicates you are opening a subprocess. The syntax may look strange, but if you have any familiarity with unix pipes, it makes more sense. I&rsquo;ve opened the IO stream here in write mode (&ldquo;w+&rdquo;) as I wish to write my query to mongo. It turns out this also gives me read access to the stream, so you can be fancy and say that the IO stream is <em>duplexed</em>. For further information on opening IO streams with open, refer to the documenation on <a href="http://ruby-doc.org/core-2.1.1/Kernel.html#method-i-open">Kernel#open</a>.</p>

<p>I&rsquo;ve hardcoded the javascript into the write method to emphasize the point, but you could make this much more dynamic with variable interpolation. Heredocs are nice because you don&rsquo;t have to fuss with quoting and you can retain formatting for readability.</p>

<p>One potential drawback is that the output will be returned in string format, so you will have to parse/split/coerce that into whatever format you need, which &ndash; depending upon your needs, may be more trouble than necessary, so YMMV.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Frozen Strings]]></title>
    <link href="http://rra3.github.io/blog/2014/01/25/frozen-strings/"/>
    <updated>2014-01-25T16:34:44-05:00</updated>
    <id>http://rra3.github.io/blog/2014/01/25/frozen-strings</id>
    <content type="html"><![CDATA[<h3>Frozen String spookiness</h3>

<p>Last week I was working on a rails project for work when I encountered something funky and slightly maddening. I was attempting to slice selected values from the HTTP request hash:</p>

<p>``` ruby plucking values from the Rails Request object</p>

<pre><code>allowed_keys = [
    "REMOTE_HOST",
    "REMOTE_ADDR",
    "HTTP_REFERER",
    "ORIGINAL_FULLPATH",
    "REQUEST_METHOD",
    "REQUEST_URI",
    "HTTP_HOST",
    "HTTP_ORIGIN",
    "HTTP_USER_AGENT",
    "REQUEST_PATH",
    "QUERY_STRING",
    "CONTENT_LENGTH"
  ]
</code></pre>

<p> self.visitor_track = self.env.slice(*allowed_keys)
<code>
...when the controller evaluated this code, it would simply stop..."freeze" if you will, emitting no errors. After some searching I discovered that Rails freezes the hash keys of core extensions. At first blush, it seemed that there was no way around the issue - no matter how I sliced or diced it, if I attempted to use the same strings in another hash, the app would choke on them. Even if you attempt a ".dup" on the string, the object's frozen flag is copied to the new string object. You can check if an object is frozen by sending the #frozen? message (and an object can be frozen with #freeze!):
</code>
2.0.0-p247 :002 > foo = [&ldquo;one&rdquo;,&ldquo;two&rdquo;,&ldquo;three&rdquo;]
 => [&ldquo;one&rdquo;, &ldquo;two&rdquo;, &ldquo;three&rdquo;]
2.0.0-p247 :003 > foo.collect! {|x| x.freeze}
 => [&ldquo;one&rdquo;, &ldquo;two&rdquo;, &ldquo;three&rdquo;]
2.0.0-p247 :004 > foo.each {|v| puts v.frozen?}
true
true
true
 => [&ldquo;one&rdquo;, &ldquo;two&rdquo;, &ldquo;three&rdquo;]
```</p>

<h3>What about symbols?</h3>

<p>A Ruby symbol is a distinctly different object type from String in Ruby, but in Rails they are interchangable with strings for hash keys &ndash; at least for the HTTP Request object.  For this and other core extensions, Rails creates any associated hashes with <a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/hash_with_indifferent_access.rb?source=cc">hash_with_indifferent_access</a>. This makes the fix for the above code very straight forward:</p>

<p>``` ruby use symbols to access data on the request instead of strings.</p>

<pre><code>allowed_keys = [
    :REMOTE_HOST,
    :REMOTE_ADDR,
    :HTTP_REFERER,
    :ORIGINAL_FULLPATH,
    :REQUEST_METHOD,
    :REQUEST_URI,
    :HTTP_HOST,
    :HTTP_ORIGIN,
    :HTTP_USER_AGENT,
    :REQUEST_PATH,
    :QUERY_STRING,
    :CONTENT_LENGTH
  ]
</code></pre>

<p> self.visitor_track = self.env.slice(*allowed_keys)
```</p>

<p>&hellip;to give your own hashes this handy behavior, just instantiate the hash using the ActiveSupport hash constructor:</p>

<p><code>ruby Endow your own hashes with "indifferent access"
foo_hash = ActiveSupport::HashWithIndifferentAccess.new
foo_hash["bar"] = "baz"
foo_hash[:bar] # =&gt; returns "baz"
</code></p>
]]></content>
  </entry>
  
</feed>
